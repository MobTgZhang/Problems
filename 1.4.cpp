/*
1.4题目：墓地雕塑(NEERC 2006,LA 3708)
在一个周长为10000的圆上等距分布着$n$个雕塑。现在又有$m$新的雕塑加入(位置可以随意放置)，希望所有$n+m$个雕塑在圆周上均匀分布。这样就需要移动其中一些原有的
雕塑。要求$n$个雕塑移动的总距离最小。
输入格式：输入包含若干组数据，每组数据仅一行，包含两个整数$n$和$m$（$2\leq n \leq 1000,1\leq m \leq 1000$）,即原始的雕塑数量和新增加的雕塑数量。输入的结束
标志为文件结束符EOF。
输出格式：输入仅一行，为最小总距离，精确到$10^{-4}$。
样例输入：
2 1
2 3
3 1
10 10
样例输出：
1666.6667
1000.0
1666.6667
0.0
*/
#include<cstdio>
#include<cmath>
int main() {
	int n, m;
	while (scanf_s("%d%d",&n,&m)==2) {
		double ans = 0.0;
		for (int k = 1; k < n; k++) {
			double pos = (double)k / n * (n + m);
			ans += fabs(pos-floor(pos+0.5))/(n+m);
		}
		printf("%.4f\n",ans*10000);
	}
	return 0;
}
